// Copyright (c) SimpleStaking and Tezos-RS Contributors
// SPDX-License-Identifier: MIT

use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use std::time::{Duration, Instant};

use failure::Error;
use log::{debug, info, trace, warn};
use riker::actors::*;

use networking::p2p::encoding::prelude::*;
use networking::p2p::network_channel::{NetworkChannelMsg, NetworkChannelRef};
use networking::p2p::peer::{PeerRef, SendMessage};
use storage::{BlockHeaderWithHash, BlockStorage, BlockStorageReader, StorageError};
use tezos_client::client::TezosStorageInitInfo;
use tezos_encoding::hash::{BlockHash, ChainId};

use crate::{subscribe_to_actor_terminated, subscribe_to_network_events};
use crate::block_state::BlockState;
use crate::operations_state::{OperationsState, MissingOperations};
use crate::shell_channel::{AllBlockOperationsReceived, BlockReceived, ShellChannelRef, ShellChannelTopic};

const BLOCK_HEADERS_BATCH_SIZE: usize = 10;
const OPERATIONS_BATCH_SIZE: usize = 10;

#[derive(Clone, Debug)]
pub struct CheckChainCompleteness;

#[actor(CheckChainCompleteness, NetworkChannelMsg, SystemEvent)]
pub struct ChainManager {
    /// All events generated by the network layer will end up in this channel
    network_channel: NetworkChannelRef,
    /// All events from shell will be published to this channel
    shell_channel: ShellChannelRef,
    /// Holds the state of all peers
    peers: HashMap<ActorUri, PeerState>,
    /// Block storage
    block_storage: Box<dyn BlockStorageReader>,
    /// Holds state of the block chain
    block_state: BlockState,
    /// Holds state of the operations
    operations_state: OperationsState,
}

pub type ChainManagerRef = ActorRef<ChainManagerMsg>;

impl ChainManager {
    pub fn actor(sys: &impl ActorRefFactory, network_channel: NetworkChannelRef, shell_channel: ShellChannelRef, rocks_db: Arc<rocksdb::DB>, tezos_storage_init_info: &TezosStorageInitInfo) -> Result<ChainManagerRef, CreateError> {
        sys.actor_of(
            Props::new_args(ChainManager::new, (network_channel, shell_channel, rocks_db, tezos_storage_init_info.chain_id.clone())),
            ChainManager::name())
    }

    /// The `ChainManager` is intended to serve as a singleton actor so that's why
    /// we won't support multiple names per instance.
    fn name() -> &'static str {
        "chain-manager"
    }

    fn new((network_channel, shell_channel, rocks_db, chain_id): (NetworkChannelRef, ShellChannelRef, Arc<rocksdb::DB>, ChainId)) -> Self {
        ChainManager {
            network_channel,
            shell_channel,
            block_storage: Box::new(BlockStorage::new(rocks_db.clone())),
            block_state: BlockState::new(rocks_db.clone(), rocks_db.clone(), &chain_id),
            operations_state: OperationsState::new(rocks_db.clone(), rocks_db),
            peers: HashMap::new(),
        }
    }

    fn check_chain_completeness(&mut self) -> Result<(), Error> {
        let ChainManager { peers, block_state, operations_state, .. } = self;

        if block_state.has_missing_blocks() {
            peers.iter_mut()
                .for_each(|(_, peer)| {
                    let available_capacity = peer.available_block_queue_capacity();
                    if available_capacity > 0 {
                        let missing_block_headers = block_state.drain_missing_blocks(available_capacity);
                        if !missing_block_headers.is_empty() {
                            debug!("Requesting {} block headers from peer {}", missing_block_headers.len(), &peer.peer_ref);
                            peer.queued_block_headers.extend(missing_block_headers.clone());
                            let msg = GetBlockHeadersMessage { get_block_headers: missing_block_headers };
                            tell_peer(msg.into(), peer);
                        }
                    }
                })
        }

        if operations_state.has_missing_operations() {
            for (_, peer) in peers.iter_mut() {
                let available_capacity = peer.available_operations_queue_capacity();
                if available_capacity > 0 {
                    let missing_operations = operations_state.drain_missing_operations(available_capacity)?;
                    if !missing_operations.is_empty() {
                        debug!("Requesting {} operations from peer {}", missing_operations.iter().map(|op| op.validation_passes.len()).sum::<usize>(), &peer.peer_ref);
                        missing_operations.iter()
                            .for_each(|operations| {
                                peer.queued_operations.insert(operations.block_hash.clone(), operations.clone());
                                let msg = GetOperationsForBlocksMessage {
                                    get_operations_for_blocks: operations.into()
                                };
                                tell_peer(msg.into(), peer);
                            });
                    }
                }
            }
        }

        Ok(())
    }

    fn process_network_channel_message(&mut self, ctx: &Context<ChainManagerMsg>, msg: NetworkChannelMsg) -> Result<(), Error> {
        let ChainManager { peers, block_state, operations_state, shell_channel, block_storage, .. } = self;
        match msg {
            NetworkChannelMsg::PeerBootstrapped(msg) => {
                debug!("Requesting current branch from peer: {}", &msg.peer);
                let mut peer = PeerState::new(msg.peer);
                tell_peer(GetCurrentBranchMessage::new(block_state.get_chain_id().clone()).into(), &mut peer);
                // store peer
                self.peers.insert(peer.peer_ref.uri().clone(), peer);
            }
            NetworkChannelMsg::PeerMessageReceived(received) => {
                match peers.get_mut(received.peer.uri()) {
                    Some(peer) => {
                        peer.response_last = Instant::now();

                        for message in &received.message.messages {
                            match message {
                                PeerMessage::CurrentBranch(message) => {
                                    debug!("Received current branch from peer: {}", &received.peer);
                                    for block_hash in message.current_branch.history.iter().cloned().rev() {
                                        block_state.push_missing_block(block_hash)?
                                    }
                                    // trigger CheckChainCompleteness
                                    ctx.myself().tell(CheckChainCompleteness, None);
                                }
                                PeerMessage::GetCurrentBranch(_) => {
                                    debug!("Current branch requested by peer: {}", &received.peer);
                                    // .. ignore
                                }
                                PeerMessage::BlockHeader(message) => {
                                    let block_header = BlockHeaderWithHash::new(message.block_header.clone()).unwrap();
                                    let block_was_expected = peer.queued_block_headers.remove(&block_header.hash);
                                    if block_was_expected {
                                        debug!("Received block header from peer: {}", &received.peer);

                                        let is_new_block = {
                                            block_state.process_block_header(block_header.clone())?;
                                            operations_state.process_block_header(&block_header)?
                                        };
                                        if is_new_block {
                                            // trigger CheckChainCompleteness
                                            ctx.myself().tell(CheckChainCompleteness, None);

                                            // notify others that new block was received
                                            shell_channel.tell(
                                                Publish {
                                                    msg: BlockReceived {
                                                        hash: block_header.hash.clone(),
                                                        level: block_header.header.level,
                                                    }.into(),
                                                    topic: ShellChannelTopic::ShellEvents.into(),
                                                }, Some(ctx.myself().into()));
                                        }
                                    } else {
                                        warn!("Received unexpected block header from peer: {}", &received.peer);
                                        ctx.system.stop(received.peer.clone());
                                    }
                                }
                                PeerMessage::OperationsForBlocks(operations) => {
                                    let block_hash = operations.operations_for_block.hash.clone();
                                    match peer.queued_operations.get_mut(&block_hash) {
                                        Some(missing_operations) => {
                                            let operation_was_expected = missing_operations.validation_passes.remove(&operations.operations_for_block.validation_pass);
                                            if operation_was_expected {
                                                debug!("Received operations validation pass #{} from peer: {}", operations.operations_for_block.validation_pass, &received.peer);
                                                if operations_state.process_block_operations(&operations)? {
                                                    // trigger CheckChainCompleteness
                                                    ctx.myself().tell(CheckChainCompleteness, None);

                                                    // notify others that new all operations for block were received
                                                    let block = block_storage.get(&block_hash)?.ok_or(StorageError::MissingKey)?;
                                                    shell_channel.tell(
                                                        Publish {
                                                            msg: AllBlockOperationsReceived {
                                                                hash: block.hash,
                                                                level: block.header.level
                                                            }.into(),
                                                            topic: ShellChannelTopic::ShellEvents.into(),
                                                        }, Some(ctx.myself().into()));

                                                    // remove operations from queue
                                                    peer.queued_operations.remove(&block_hash);
                                                }
                                            } else {
                                                warn!("Received unexpected validation pass #{} from peer: {}", operations.operations_for_block.validation_pass, &received.peer);
                                                ctx.system.stop(received.peer.clone());
                                            }
                                        }
                                        None => {
                                            warn!("Received unexpected operations from peer: {}", &received.peer);
                                            ctx.system.stop(received.peer.clone());
                                        }
                                    }
                                }
                                _ => trace!("Ignored message: {:?}", message)
                            }
                        }
                    }
                    None => debug!("Received message from non-existing peer: {}", &received.peer)
                }
            }
            _ => (),
        }

        Ok(())
    }
}

impl Actor for ChainManager {
    type Msg = ChainManagerMsg;

    fn pre_start(&mut self, ctx: &Context<Self::Msg>) {
        subscribe_to_actor_terminated(ctx.system.sys_events(), ctx.myself());
        subscribe_to_network_events(&self.network_channel, ctx.myself());

        info!("Hydrating block state");
        self.block_state.hydrate().expect("Failed to hydrate block state");
        info!("Hydrating operations state");
        self.operations_state.hydrate().expect("Failed to hydrate operations state");
        info!("Hydrating completed successfully");

        ctx.schedule::<Self::Msg, _>(
            Duration::from_secs(15),
            Duration::from_secs(60),
            ctx.myself(),
            None,
            CheckChainCompleteness.into());
    }

    fn sys_recv(&mut self, ctx: &Context<Self::Msg>, msg: SystemMsg, sender: Option<BasicActorRef>) {
        if let SystemMsg::Event(evt) = msg {
            self.receive(ctx, evt, sender);
        }
    }

    fn recv(&mut self, ctx: &Context<Self::Msg>, msg: Self::Msg, sender: Sender) {
        self.receive(ctx, msg, sender);
    }
}

impl Receive<SystemEvent> for ChainManager {
    type Msg = ChainManagerMsg;

    fn receive(&mut self, _ctx: &Context<Self::Msg>, msg: SystemEvent, _sender: Option<BasicActorRef>) {
        if let SystemEvent::ActorTerminated(evt) = msg {
            if let Some(mut peer) = self.peers.remove(evt.actor.uri()) {
                peer.queued_block_headers
                    .drain()
                    .for_each(|block_hash| {
                        self.block_state.push_missing_block(block_hash).expect("Failed to re-schedule block hash");
                    });

                self.operations_state.push_missing_operations(peer.queued_operations.drain().map(|(_, op)| op))
                    .expect("Failed to return to queue")
            }
        }
    }
}

impl Receive<CheckChainCompleteness> for ChainManager {
    type Msg = ChainManagerMsg;

    fn receive(&mut self, _ctx: &Context<Self::Msg>, _msg: CheckChainCompleteness, _sender: Sender) {
        match self.check_chain_completeness() {
            Ok(_) => (),
            Err(e) => warn!("Failed to check chain completeness: {:?}", e),
        }
    }
}

impl Receive<NetworkChannelMsg> for ChainManager {
    type Msg = ChainManagerMsg;

    fn receive(&mut self, ctx: &Context<Self::Msg>, msg: NetworkChannelMsg, _sender: Sender) {
        match self.process_network_channel_message(ctx, msg) {
            Ok(_) => (),
            Err(e) => warn!("Failed to process network channel message: {:?}", e),
        }
    }
}

struct PeerState {
    peer_ref: PeerRef,
    queued_block_headers: HashSet<BlockHash>,
    queued_operations: HashMap<BlockHash, MissingOperations>,
    request_last: Instant,
    response_last: Instant,
}

impl PeerState {
    fn new(peer_ref: PeerRef) -> Self {
        PeerState {
            peer_ref,
            queued_block_headers: HashSet::new(),
            queued_operations: HashMap::new(),
            request_last: Instant::now(),
            response_last: Instant::now(),
        }
    }

    fn available_block_queue_capacity(&self) -> usize {
        let queued_count = self.queued_block_headers.len();
        if queued_count < BLOCK_HEADERS_BATCH_SIZE {
            BLOCK_HEADERS_BATCH_SIZE - queued_count
        } else {
            0
        }
    }

    fn available_operations_queue_capacity(&self) -> usize {
        let queued_count = self.queued_operations.len();
        if queued_count < OPERATIONS_BATCH_SIZE {
            OPERATIONS_BATCH_SIZE - queued_count
        } else {
            0
        }
    }
}


fn tell_peer(msg: PeerMessageResponse, peer: &mut PeerState) {
    peer.peer_ref.tell(SendMessage::new(msg), None);
    peer.request_last = Instant::now();
}